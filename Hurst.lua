SMA="SMA"WMA="WMA"EMA="EMA"SMMA="SMMA"WILLMA="WILLMA"Settings = {       --период равен min_len*2^accuracy    Name = "*Hurst",     accuracy = 4, -- минимум 4    min_len = 3, -- минимум 3        value_type = "C",     line=   {                 {                 Name = "Hurst",                 Color = RGB(180, 200, 240),                 Type = TYPE_LINE,                 Width = 2                 }            } } function Init()     Dimension = Hurst()    return 1endfunction OnCalculate(index)      local FD = Dimension(index, Settings.accuracy, Settings.min_len, Settings.value_type)          return FDendfunction dValue(i,param)local v = param or "C"	if  v == "O" then		return O(i)	elseif   v == "H" then		return H(i)	elseif   v == "L" then		return L(i)	elseif   v == "C" then		return C(i)	elseif   v == "V" then		return V(i)	elseif   v == "M" then		return (H(i) + L(i))/2	elseif   v == "T" then		return (H(i) + L(i)+C(i))/3	elseif   v == "W" then		return (H(i) + L(i)+2*C(i))/4	elseif   v == "ATR" then		return math.max(math.abs(H(i) - L(i)), math.abs(H(i) - C(i-1)), math.abs(C(i-1) - L(i)))	else		return C(i)	end endfunction Hurst()    local RS = RSn()    local Xn = 0    local Yn = 0    return function(ind, accuracy, min_length, v_t)                local index = ind        local v_type = v_t        local min_len = min_length         local acc = accuracy        local p = math.pow(2,acc)*min_len+1                local Hurst = 0          local c1 = 0        local c2 = 0        local g1 = 0        local g2 = 0                if index<=p then            return nil        end                for i = 1, acc do            local len = min_length*math.pow(2,(i-1))            Xn = math.log(len)             local RSi =  RS(index,p,len,v_type)            Yn = math.log(RSi)            c1=c1+Xn*Xn            c2=c2+Xn            g1=g1+Xn*Yn            g2=g2+Yn        end                Hurst =  (acc*g1 - c2*g2)/(acc*c1 - c2*c2)         return Hurst          endend--считает приращениеfunction increment_series()    return function(ind, v_t)                local v_type = v_t         local index = ind         if index == 1 then             return nil         end                local n = math.log(dValue(index, v_type)/dValue(index-1, v_type))        return n         endend--считает среднее значение приращенийfunction average_increment_series()    local inc = increment_series()    return function(ind, period, v_t)        local index = ind        local v_type = v_t        local p = period        local avg = 0        local sum = 0        if index<=p then            return nil        end                for i = index-p+1, index do             sum=sum+inc(i,v_type)        end        return  sum/p    endend--функция считает RS для разбиения на отрезки длиной lenfunction RSn()    local inc = increment_series()    local avg_inc = average_increment_series()          return function(ind, period, length, v_t)        local p = period        local index = ind        local v_type = v_t        local len = length         local N = math.floor((p-1)/len)        local RS_sum = 0          if index<=p then            return nil        end                for i = 1, N do            local Dka = (inc(index-(i-1)*len,v_type) - avg_inc(index-(i-1)*len,len,v_type))            local Xka = Dka            local Xka_min = Dka            local Xka_max = Dka            local Xka2 = Dka*Dka            for k=2, len do                Dka=(inc(index-(i-1)*len+(1-k),v_type) - avg_inc(index-(i-1)*len,len,v_type)) -- отклонение k из отрезка i                                 Xka=Xka+Dka                Xka2=Xka2+Dka*Dka                if Xka<Xka_min then                    Xka_min = Xka                end                if Xka>Xka_max then                    Xka_max = Xka                end            end            local Ri = (Xka_max - Xka_min)            local Si = math.sqrt((1/len)*Xka2)                        RS_sum = RS_sum+(Ri/Si)        end        return RS_sum/N    endend