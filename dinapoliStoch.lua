--logfile=io.open("C:\\SBERBANK\\QUIK_SMS\\LuaIndicators\\qlua_log.txt", "w")min_price_step = 0Settings = {	Name = "*DinapoliStochastic",	FastK = 8,	SlowK = 3,	SlowD = 3,	periodEMA = 1,	line =     {         {          Name = "signal",          Color = RGB(255,10,0),          Type = TYPE_LINE,          Width =1         },        {          Name = "line",          Color = RGB(10,255,50),          Type = TYPE_LINE,          Width =1         },         {          Name = "20",          Color = RGB(0,0,0),          Type = TYPE_LINE,          Width =1         },        {          Name = "80",          Color = RGB(0,0,50),          Type = TYPE_LINE,          Width =1         }    } }function dValue(i,param)local v = param or "C"		if not CandleExist(i) then		return nil	end		if  v == "O" then		return O(i)	elseif   v == "H" then		return H(i)	elseif   v == "L" then		return L(i)	elseif   v == "C" then		return C(i)	elseif   v == "V" then		return V(i)	elseif   v == "M" then		return (H(i) + L(i))/2	elseif   v == "T" then		return (H(i) + L(i)+C(i))/3	elseif   v == "W" then		return (H(i) + L(i)+2*C(i))/4	elseif   v == "ATR" then		local previous = math.max(i-1, 1)					if not CandleExist(previous) then			previous = FindExistCandle(previous)		end		if previous == 0 then			return nil		end			return math.max(math.abs(H(i) - L(i)), math.abs(H(i) - C(previous)), math.abs(C(previous) - L(i)))	else		return C(i)	end endfunction FindExistCandle(I)	local out = I		while not CandleExist(out) and out > 0 do		out = out -1	end			return out end function Init()	myfunc = Stoch()	return #Settings.line end function OnCalculate(index)	--WriteLog ("OnCalc() ".."CandleExist("..index.."): "..tostring(CandleExist(index)));	if index == 1 then		DSInfo = getDataSourceInfo()     			min_price_step = getParamEx(DSInfo.class_code, DSInfo.sec_code, "SEC_PRICE_STEP").param_value	end	return myfunc(index, Settings) end  -- Пользовательcкие функцииfunction WriteLog(text)   logfile:write(tostring(os.date("%c",os.time())).." "..text.."\n");   logfile:flush();   LASTLOGSTRING = text;end function Stoch()		local cache_ValueHH = {}	local cache_ValueLL = {}	local cache_StoBuffer = {}	local cache_SigBuffer = {}	local cache_outEMA = {}		return function(ind, Fsettings)				local Fsettings=(Fsettings or {})		local index = ind		local FastK = Fsettings.FastK or 8		local SlowK = Fsettings.SlowK or 3		local SlowD = Fsettings.SlowD or 3		local periodEMA = Fsettings.periodEMA or 3		local out1 = nil		local out2 = nil		local HH = 0 		local LL = 0		local Range = 0		local Res = 0		local k = 2/(periodEMA+1)						if index == 1 then			cache_ValueHH = {}			cache_ValueLL = {}			cache_StoBuffer = {}			cache_SigBuffer = {}			cache_outEMA = {}						cache_ValueHH[index]= 0			cache_ValueLL[index]= 0			cache_StoBuffer[index]= 50			cache_SigBuffer[index]= 50			cache_outEMA[index]= 50						return out		end						cache_ValueHH[index] = dValue(index, "H") or cache_ValueHH[index-1]			cache_ValueLL[index] = dValue(index, "L") or cache_ValueLL[index-1]			cache_StoBuffer[index] = cache_StoBuffer[index-1]		cache_SigBuffer[index] = cache_SigBuffer[index-1]		cache_outEMA[index] = cache_outEMA[index-1]		if not CandleExist(index) or index <= FastK then			return nil		end						HH = math.max(unpack(cache_ValueHH,index-FastK,index)) 		LL = math.min(unpack(cache_ValueLL,index-FastK,index))						Range = math.max(HH-LL,1*min_price_step)				Res=100*(C(index)-LL)/Range;		cache_StoBuffer[index]=cache_StoBuffer[index-1]+(Res-cache_StoBuffer[index-1])/SlowK;            --stochastic line		cache_SigBuffer[index]=cache_SigBuffer[index-1]+(cache_StoBuffer[index]-cache_SigBuffer[index-1])/SlowD; --signal line		cache_outEMA[index] = k*cache_StoBuffer[index]+(1-k)*cache_outEMA[index-1]						out1 = cache_SigBuffer[index]		out2 = cache_outEMA[index]						return out1, out2, 20, 80				endend